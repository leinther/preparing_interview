# Tree

Ссылка: http://algcourse.cs.msu.su/?page_id=30

**Дерево** — это [связный](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D0%B3%D1%80%D0%B0%D1%84) [ациклический граф](https://ru.wikipedia.org/wiki/%D0%90%D1%86%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B3%D1%80%D0%B0%D1%84). Связность означает наличие маршрута между любой парой вершин, ацикличность — отсутствие циклов. Отсюда, в частности, следует, что число рёбер в дереве на единицу меньше числа вершин, а между любыми парами вершин имеется один и только один путь.

- Формально дерево (tree) определяется как конечное множество T одного или более узлов. Каждый узел дерева является корнем некоторого поддерева данного дерева.  Количество поддеревьев узла называется *степенью* (degree) этого узла.
- Узел со степенью нуль называется *концевым узлом* (terminal node) или *листом* (leaf).
- Неконцевой узел называется *узлом ветвления* (branch node). *Уровень* (level) узла по отношению к дереву T определяется рекурсивно следующим образом. Уровень корня дерева T равен нулю, а уровень любого другого узла на единицу выше, чем уровень корня ближайшего поддерева дерева T , содержащего данный узел.

***Виды обхода***: 1) прямой **(root → left → right)** ; 2) центрированый **(left → root → right)**; 3) обратный **(left → right → root )**

---

***Как инвертировать бинарное дерево? С помошью рекурсии спуститься влево вниз, и поменять правый и левый указатель местами.***

![invert1-tree.jpg](Tree%2018c956f3ace4475e83048781f5ad5aea/invert1-tree.jpg)

```python
def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return 
        self.invertTree(root.left)
        self.invertTree(root.right)
        root.left, root.right = root.right, root.left
        return root
```

---

### ***Бинарное дерево поиска (англ. binary search tree, BST) — структура данных для работы с [упорядоченными множествами](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D1%87%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE). Бинарное дерево поиска обладает следующим свойством: если x — узел бинарного дерева с ключом k, то все узлы в левом поддереве должны иметь ключи, меньшие k, а в правом поддереве большие k.***

***Пример бинарного дерева поиска***

```python
class Tree:
    def __init__(self,data = None):
        self.data = data  
        self.left = None
        self.right = None
    
    def insert(self,value):
        if value < self.data:
            if self.left is None:
                self.left = Tree (value)
            else:
                self.left.insert(value)
        if value > self.data:
            if self.right is None:
                self.right = Tree (value)
            else:
                self.right.insert(value)

    def traverse(self,root):
        current = root
        if current is None:
            return
        print(current.data)
        self.traverse(current.left)
        self.traverse(current.right)

root = Tree(3)
root.insert(2)
root.insert(4)
root.insert(2)
root.traverse(root)
```

---

![Treedatastructure.png](Tree%2018c956f3ace4475e83048781f5ad5aea/Treedatastructure.png)

Каждый узел называется родителем (parent) корней его поддеревьев, а сами корни называются братьями-сестрами (siblings), а также детьми (children) своего родителя. 

Лес (forest) — это множество (обычно упорядоченное), не содержащее ни одного непересекающегося дерева или содержащее несколько непересекающихся деревьев.

Глубина: общее количество ребер от корневого узла до определенного узла называется глубиной этого узла.

Высота дерева – это максимальная длина пути от корня до листа.

Big O дерева поиска - O(h)

![msedge_cK57cbYbWU.png](Tree%2018c956f3ace4475e83048781f5ad5aea/msedge_cK57cbYbWU.png)

для обозначения родства, которое может простираться на несколько уровней дерева, будут использоваться термины “предок” (ancestor) и “потомок” (descendant). Например, потомками узла C на рис. 19 являются узлы D, E, F и G, а предками узла G— узлы E, C и A

---

### Поиск минимума и максимума в бинарном дереве поиска

Чтобы найти минимальный элемент в бинарном дереве поиска, необходимо просто следовать указателям left от корня дерева, пока не встретится значение null. Если у вершины есть левое поддерево, то по свойству бинарного дерева поиска в нем хранятся все элементы с меньшим ключом. Если его нет, значит эта вершина и есть минимальная. Аналогично ищется и максимальный элемент. Для этого нужно следовать правым указателям.

```python
def minimum (self):
        if self.left is None:
            print(self.data)
            return self.data
        else:
            self.left.minimum()
```

### **Восстановление дерева по результату обхода preorderTraversal**

![BST_from_seq.gif](Tree%2018c956f3ace4475e83048781f5ad5aea/BST_from_seq.gif)

***Как мы помним, процедура preorderTraversal выводит значения в узлах поддерева следующим образом: сначала идёт до упора влево, затем на каком-то моменте делает шаг вправо и снова движется влево. Это продолжается до тех пор, пока не будут выведены все вершины. Полученная последовательность позволит нам однозначно определить расположение всех узлов поддерева. Первая вершина всегда будет в корне. Затем, пока не будут использованы все значения, будем последовательно подвешивать левых сыновей к последней добавленной вершине, пока не найдём номер, нарушающий убывающую последовательность, а для каждого такого номера будем искать вершину без правого потомка, хранящую наибольшее значение, не превосходящее того, которое хотим поставить, и подвешиваем к ней элемент с таким номером в качестве правого сына. Когда мы, желая найти такую вершину, встречаем какую-нибудь другую, уже имеющую правого сына, проходим по ветке вправо. Мы имеем на это право, так как если такая вершина стоит, то процедура обхода в ней уже побывала и поворачивала вправо, поэтому спускаться в другую сторону смысла не имеет. Вершину с максимальным ключом, с которой будем начинать поиск, будем запоминать. Она будет обновляться каждый раз, когда появится новый максимум.***

***Процедура восстановления дерева работает за O(n).***

---

### Удаление узла из двоичного дерева

![Untitled](Tree%2018c956f3ace4475e83048781f5ad5aea/Untitled.png)