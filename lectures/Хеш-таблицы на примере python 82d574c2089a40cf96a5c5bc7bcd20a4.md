# Хеш-таблицы на примере python

Ссылка: https://realpython.com/python-hash-table/#build-a-hash-table-prototype-in-python-with-tdd
Ссылка 1 : https://www.geeksforgeeks.org/implementation-of-hash-table-in-python-using-separate-chaining/

**Хеш-табли́ца (англ. *hash-table*) — структура данных, реализующая интерфейс ассоциативного массива. В отличие от [деревьев поиска](https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0,_%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F), реализующих тот же интерфейс, обеспечивают меньшее время отклика в среднем. Представляет собой эффективную структуру данных для реализации словарей, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.**

Хеш-таблица основывается на массиве. Хеш таблица имеет следующую структуру: 1) массив занимает непрерывный блок памяти; 2) каждый элемент массива имеет фиксированный размер 

![robocrop.realpython.webp](%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B%20%D0%BD%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5%20python%2082d574c2089a40cf96a5c5bc7bcd20a4/robocrop.realpython.webp)

**Хеширование состоит из 3 этапов: 1) принимаеться ключ; 2) ключ подается на вход хеш-функции; 3) хеш переводиться в целое число, которое сопоставляется с индексом в массиве**

### Разрешение колизий при помощи цепочек

`**Создается класс Хэш таблицы, при инициализации указываем таблицу, в которой будем хранить пару ключ-значение, capacity - вместимость нашей таблицы и размер. Создается функция, которая будет хешировать наши ключи в индексы.**`

`**И самое главное - решение коллизии заключается в том, что если наша ячейка уже занята и в ячейке разные ключи, то мы создаем цепочку в виде связного списка в этой ячейке.**`

![msedge_wVhlC7SQOx.png](%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B%20%D0%BD%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B5%20python%2082d574c2089a40cf96a5c5bc7bcd20a4/msedge_wVhlC7SQOx.png)

- **Хеш-таблица с цепочками**
    
    ```python
    class Node: 
        def __init__(self, key, value): 
            self.key = key 
            self.value = value 
            self.next = None
      
      
    class HashTable: 
        def __init__(self, capacity): 
            self.capacity = capacity 
            self.size = 0
            self.table = [None] * capacity 
      
        def _hash(self, key): 
            return hash(key) % self.capacity 
      
        def insert(self, key, value): 
            index = self._hash(key) 
      
            if self.table[index] is None: 
                self.table[index] = Node(key, value) 
                self.size += 1
            else: 
                current = self.table[index] 
                while current: 
                    if current.key == key: 
                        current.value = value 
                        return
                    current = current.next
                new_node = Node(key, value) 
                new_node.next = self.table[index] 
                self.table[index] = new_node 
                self.size += 1
      
        def search(self, key): 
            index = self._hash(key) 
      
            current = self.table[index] 
            while current: 
                if current.key == key: 
                    return current.value 
                current = current.next
      
            raise KeyError(key) 
      
        def remove(self, key): 
            index = self._hash(key) 
      
            previous = None
            current = self.table[index] 
      
            while current: 
                if current.key == key: 
                    if previous: 
                        previous.next = current.next
                    else: 
                        self.table[index] = current.next
                    self.size -= 1
                    return
                previous = current 
                current = current.next
      
            raise KeyError(key) 
      
        def __len__(self): 
            return self.size 
      
        def __contains__(self, key): 
            try: 
                self.search(key) 
                return True
            except KeyError: 
                return False
    ```
    

**Открытая адресация**

В массиве *H* хранятся сами пары ключ-значение. Алгоритм вставки элемента проверяет ячейки массива *H* в некотором порядке до тех пор, пока не будет найдена первая свободная ячейка, в которую и будет записан новый элемент. Этот порядок вычисляется на лету, что позволяет сэкономить на памяти для указателей, требующихся в хеш-таблицах с цепочками.

Последовательность, в которой просматриваются ячейки хеш-таблицы, называется **последовательностью проб**. В общем случае, она зависит только от ключа элемента, то есть это последовательность *h*0(*x*), *h*1(*x*), …, *hn* — 1(*x*), где *x* — ключ элемента, а *hi*(*x*) — произвольные функции, сопоставляющие каждому ключу ячейку в хеш-таблице. Первый элемент в последовательности, как правило, равен значению некоторой хеш-функции от ключа, а остальные считаются от него одним из приведённых ниже способов. Для успешной работы алгоритмов поиска последовательность проб должна быть такой, чтобы все ячейки хеш-таблицы оказались просмотренными ровно по одному разу.

Алгоритм поиска просматривает ячейки хеш-таблицы в том же самом порядке, что и при вставке, до тех пор, пока не найдется либо элемент с искомым ключом, либо свободная ячейка (что означает отсутствие элемента в хеш-таблице).

Удаление элементов в такой схеме несколько затруднено. Обычно поступают так: заводят булевый флаг для каждой ячейки, помечающий, удален элемент в ней или нет. Тогда удаление элемента состоит в установке этого флага для соответствующей ячейки хеш-таблицы, но при этом необходимо модифицировать процедуру поиска существующего элемента так, чтобы она считала удалённые ячейки занятыми, а процедуру добавления — чтобы она их считала свободными и сбрасывала значение флага при добавлении.

**Последовательности проб**

Ниже приведены некоторые распространенные типы последовательностей проб. Сразу оговорим, что нумерация элементов последовательности проб и ячеек хеш-таблицы ведётся от нуля, а *N* — размер хеш-таблицы (и, как замечено выше, также и длина последовательности проб).

- [Линейное пробирование](https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%BE%D0%B5_%D0%B7%D0%BE%D0%BD%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5): ячейки хеш-таблицы последовательно просматриваются с некоторым фиксированным интервалом *k* между ячейками (обычно *k* = 1), то есть *i*й элемент последовательности проб — это ячейка с номером (hash(*x*) + *ik*) mod *N*. Для того, чтобы все ячейки оказались просмотренными по одному разу, необходимо, чтобы *k* было [взаимно-простым](https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D1%82%D0%B0) с размером хеш-таблицы.
- [Квадратичное пробирование](https://ru.wikipedia.org/w/index.php?title=%D0%9A%D0%B2%D0%B0%D0%B4%D1%80%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5&action=edit&redlink=1): интервал между ячейками с каждым шагом увеличивается на константу. Если размер хеш-таблицы равен степени двойки (*N* = 2), то одним из примеров последовательности, при которой каждый элемент будет просмотрен по одному разу
- [Двойное хеширование](https://ru.wikipedia.org/w/index.php?title=%D0%94%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B5_%D1%85%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5&action=edit&redlink=1): интервал между ячейками фиксирован, как при линейном пробировании, но, в отличие от него, размер интервала вычисляется второй, вспомогательной хеш-функцией, а значит, может быть различным для разных ключей. Значения этой хеш-функции должны быть ненулевыми и взаимно-простыми с размером хеш-таблицы, что проще всего достичь, взяв [простое число](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE) в качестве размера, и потребовав, чтобы вспомогательная хеш-функция принимала значения от 1 до *N* — 1.

Недостаток открытой адресации, в том что при увеличении количества ключей и приближении к **коэффициенту заполнения хеш-таблицы нам приходиться расширять массив, а также перехеширвать существующие элементы, что сказываеться в скорости работы.**